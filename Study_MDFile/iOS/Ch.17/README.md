# Ch.17 사용자에게 메세지를 전달하는 방법

1.메세지창(알림창)
2.로컬알림
3.서버알림(푸시알림)
## 17.1 메시지 알림창 -UIAlertController

- iOS에서 메시지창을 구현하는 객체는 UIAlertController
- 뷰컨트롤러의 일종
- 두가지의 메세지창표현가능함(알림창, 액션시트)
- 알림창은 모달방식으로 화면에 표시
- 액션시트창은 모달방식이 아님
- 알림차에는 텍스트 필드 추가가능 하지만 액션시트 창에는 추가불가함
- UIAlertView 와 UIActionSheet 따로 존재했었음.
- iOS 8.0이후 UIAlertController로 통합
- 버튼은 UIAlertAction 객체에 의해 구현됨
- 액션시트 모든 버튼을 무조건 목록처럼 배열하지만 알림창에서는 선택버튼이 세개이상부터 버튼목록처럼 구성됨

### 17.1.1 UIAlertController
- .cancel 로 설정된 객체는 항상 메시지창의 맨 아래에 위치하는 특성을 가짐
- 이 점은 액션시트에서도 마찬가지임. 특히 액션시트에 .cancel 타입으로 설정된 버튼은 화면 제일 아래에 분리되어 표시됨
- .cancel 타입으로 설정된 버튼은 특별한 취급을 받기 때문에 하나의 메시지 창 내에서 한번만 사용할수 있음
- 화면이 표시됨과 동시에 메세지 창을 띄워주어야 할 때가 있음(네트워크 기반 서비스에서 네트워크가 연결되지 않았을때가 대표적)
- 이때에는 사용자의 액션이 없이도 곧바로 메세지 창을 띄워 현재의 상태를 알려줘야함.
- 이때 viewDidLoad()메소드 내에 메세지창 구현하여 실행하면 런타임 오류..(아직 메세지창을 처리해줄 뷰가 화면에 구현되지 않은 상태에서 먼저 화면 전환을 시도했기때문임)
- 이를 피하기 위해 viewDidAppear(_:)메소드를 이용하여 메세지창을 처리해주어야 함
- 뷰객체가 메모리에만 올라온 상태에서 호출되는 viewDidLoad(_:)와 달리 
- viewDidAppear(_:)은 뷰가 완전히 화면에 표시되고 난 다음에 호출되기 때문에 메세지 창을 띄우기 위한 프레젠트 메소드를 실행하는데 아무런 문제가 없음 

### 17.1.2 입력필드를 가지는 메세지창

## 17.2 로컬알림
- 로컬알림은 앱 내부에서 만든 특정 메시지를 iOS의 알림센터를 통해 전달하는 방법. 앱이 종료되어 있거나 백그라운드 상태일 때 메시지를 전달할 수 있는 대표적인 방법중의 하나임
- 로컬알림은 iOS스케줄러에 의해 발송, 앱 내부에서 미리 메시지를 구성한후 발송될 시각을 iOS스케줄러에 등록해 두면 해당 시각에 맞추어 자동으로 발송
- 스케줄러에 의해 관리되므로 앱이 실행중이 아니더라도 메시지를 받을 수 있을 뿐만 아니라 알림 센터에 표시된 메시지를 클릭하여 앱을 실행시키고 원하는 기능을 실행하거나 특정 화면으로 이동하게끔 처리할 수도 있음
- 로컬알림용 객체는 UILocalNotification

# 17.2.2 받은 알림 처리하기
